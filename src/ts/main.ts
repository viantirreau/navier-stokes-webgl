import * as Utils from "./gl-utils/utils";
import FBO from "./gl-utils/fbo";
import * as Parameters from "./parameters";
import Brush from "./brush";
import ObstacleMap from "./obstacle-map";
import Fluid from "./fluid";
import * as Requirements from "./requirements";

import "./page-interface-generated";

/** Initializes a WebGL context */
function initGL(canvas: HTMLCanvasElement, flags: any): WebGLRenderingContext {
  function setError(message: string) {
    Page.Demopage.setErrorMessage("webgl-support", message);
  }

  let gl: WebGLRenderingContext = canvas.getContext(
    "webgl",
    flags
  ) as WebGLRenderingContext;
  if (!gl) {
    gl = canvas.getContext(
      "experimental-webgl",
      flags
    ) as WebGLRenderingContext;
    if (!gl) {
      setError("Your browser or device does not seem to support WebGL.");
      return null;
    }
    setError(
      "Your browser or device only supports experimental WebGL.\n" +
        "The simulation may not run as expected."
    );
  }

  if (gl) {
    canvas.style.cursor = "none";
    gl.disable(gl.CULL_FACE);
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.BLEND);
    gl.clearColor(0.0, 0.0, 0.0, 1.0);

    Utils.resizeCanvas(gl, false);
  }

  return gl;
}

function main() {
  const canvas: HTMLCanvasElement = Page.Canvas.getCanvas();
  const gl: WebGLRenderingContext = initGL(canvas, {
    alpha: false,
    antialias: false,
  });
  if (!gl || !Requirements.check(gl)) return;

  const extensions: string[] = [
    "OES_texture_float",
    "WEBGL_color_buffer_float",
    "OES_texture_float_linear",
  ];
  Requirements.loadExtensions(gl, extensions);

  const size = 1024;

  const fluid = new Fluid(gl, size, size);
  const brush = new Brush(gl);
  const obstacleMap = new ObstacleMap(gl, size, size);
  Parameters.bind(fluid);

  /* Update the FPS indicator every second. */
  let instantFPS: number = 0;
  const updateFpsText = function () {
    Page.Canvas.setIndicatorText("fps", instantFPS.toFixed(0));
  };
  setInterval(updateFpsText, 1000);
  let lastUpdate = 0;
  let waitForPrint = 1000;
  let willPrint = true;
  function mainLoop(time: number) {
    time *= 0.001; //dt is now in seconds
    let dt = time - lastUpdate;
    instantFPS = 1 / dt;
    lastUpdate = time;

    /* If the javascript was paused (tab lost focus), the dt may be too big.
     * In that case we adjust it so the simulation resumes correctly. */
    dt = Math.min(dt, 1 / 10);

    /* Updating */
    if (Parameters.fluid.stream) {
      fluid.addVel([0.1, 0.5], [0.05, 0.7], [0.04, 0]);
    }
    fluid.update(obstacleMap);

    /* Drawing */
    FBO.bindDefault(gl);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    if (Parameters.display.velocity) {
      fluid.drawVelocity();
    } else if (Parameters.display.pressure) {
      fluid.drawPressure();
    }

    if (Parameters.display.brush) {
      brush.draw();
    }

    if (Parameters.display.obstacles) {
      obstacleMap.draw();
    }

    // Update the turbine's angular velocity as a function
    // of the torque generated by the pressure differential
    // on each of its blades
    obstacleMap.computeTurbineTorque(
      fluid.samplePressure(),
      fluid.width,
      fluid.height
    );
    // Redraw the obstacle textures on the GPU shaders
    obstacleMap.update(
      dt,
      Parameters.bladeInfo.bladeCount,
      Parameters.bladeInfo.radius,
      Parameters.bladeInfo.centerOffset
    );

    requestAnimationFrame(mainLoop);
  }

  requestAnimationFrame(mainLoop);
}

main();
