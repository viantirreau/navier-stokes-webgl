import * as Utils from "./gl-utils/utils";
import FBO from "./gl-utils/fbo";
import * as Parameters from "./parameters";
import Brush from "./brush";
import ObstacleMap from "./obstacle-map";
import Fluid from "./fluid";
import * as Requirements from "./requirements";

import "./page-interface-generated";

/** Initializes a WebGL context */
function initGL(canvas: HTMLCanvasElement, flags: any): WebGLRenderingContext {
  function setError(message: string) {
    Page.Demopage.setErrorMessage("webgl-support", message);
  }

  let gl: WebGLRenderingContext = canvas.getContext(
    "webgl",
    flags
  ) as WebGLRenderingContext;
  if (!gl) {
    gl = canvas.getContext(
      "experimental-webgl",
      flags
    ) as WebGLRenderingContext;
    if (!gl) {
      setError("Tu navegador o dispositivo no parece soportar WebGL ðŸ˜¢");
      return null;
    }
    setError(
      "Tu navegador o dispositivo solo soporta una versiÃ³n experimental de WebGL.\n" +
        "La simulaciÃ³n puede tener un comportamiento inesperado."
    );
  }

  if (gl) {
    canvas.style.cursor = "none";
    gl.disable(gl.CULL_FACE);
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.BLEND);
    gl.clearColor(0.0, 0.0, 0.0, 1.0);

    Utils.resizeCanvas(gl, false);
  }

  return gl;
}

function main() {
  const canvas: HTMLCanvasElement = Page.Canvas.getCanvas();
  const gl: WebGLRenderingContext = initGL(canvas, {
    alpha: false,
    antialias: false,
  });
  if (!gl || !Requirements.check(gl)) return;

  const extensions: string[] = [
    "OES_texture_float",
    "WEBGL_color_buffer_float",
    "OES_texture_float_linear",
  ];
  Requirements.loadExtensions(gl, extensions);

  const size = 1024;

  const fluid = new Fluid(gl, size, size);
  const brush = new Brush(gl);
  const obstacleMap = new ObstacleMap(gl, size, size);
  Parameters.bind(fluid);

  /* Update the FPS indicator every second. */
  let instantFPS: number = 0;
  const updateFpsText = function () {
    Page.Canvas.setIndicatorText("fps", instantFPS.toFixed(0));
  };
  /* Update the power generated by the turbine.
     Uses an exponential moving average */
  let movAvgPower: number = 0;
  // Average over ~1000 periods by the formula alpha = 2/(n+1), for n periods
  const movAvgAlpha = 0.002;
  let instantPowPrev = 0;
  let instantPow = 0;
  const updatePowerText = () => {
    Page.Canvas.setIndicatorText("power", `${movAvgPower.toFixed(2)} kW`);
  };
  setInterval(updateFpsText, 1000);
  setInterval(updatePowerText, 1000);
  let lastUpdate = 0;
  function mainLoop(time: number) {
    time *= 0.001; //dt is now in seconds
    let dt = time - lastUpdate;
    instantFPS = 1 / dt;
    lastUpdate = time;

    /* If the javascript was paused (tab lost focus), the dt may be too big.
     * In that case we adjust it so the simulation resumes correctly. */
    dt = Math.min(dt, 1 / 10);

    /* Updating */
    if (Parameters.fluid.stream) {
      // [xCenter, yCenter], [width, height], [uSpeed, vSpeed]
      fluid.addVel(
        [0.1, 0.85 - 0.5 * Parameters.fluid.streamHeight],
        [0.05, Parameters.fluid.streamHeight],
        [0.04, 0]
      );
    }
    fluid.update(obstacleMap);

    /* Drawing */
    FBO.bindDefault(gl);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    if (Parameters.display.velocity) {
      fluid.drawVelocity();
    } else if (Parameters.display.pressure) {
      fluid.drawPressure();
    }

    if (Parameters.display.brush) {
      brush.draw();
    }

    if (Parameters.display.obstacles) {
      obstacleMap.draw();
    }

    // Update the turbine's angular velocity as a function
    // of the torque generated by the pressure differential
    // on each of its blades.
    // Also, update the generated power moving average
    // with the formula avgPow(t) = alpha * instantPow(t) + (1 - alpha) * instantPow(t-1)
    instantPow = obstacleMap.computeTurbineTorque(
      fluid.samplePressure(),
      fluid.width,
      fluid.height
    );
    movAvgPower = movAvgAlpha * instantPow + (1 - movAvgAlpha) * instantPowPrev;
    instantPowPrev = instantPow;

    // Redraw the obstacle textures on the GPU shaders
    obstacleMap.update(
      dt,
      Parameters.bladeInfo.bladeCount,
      Parameters.bladeInfo.radius,
      Parameters.bladeInfo.centerOffset
    );

    requestAnimationFrame(mainLoop);
  }

  requestAnimationFrame(mainLoop);
}

main();
